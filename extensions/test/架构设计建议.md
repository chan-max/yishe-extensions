# Chrome 插件架构设计建议

## 推荐方案：单插件 + 模块化架构

对于您的需求（多个网站爬取 + 其他功能），**推荐使用单插件 + 模块化架构**。

## 目录结构建议

```
your-extension/
├── manifest.json
├── popup.html
├── popup.js
├── background/
│   ├── background.js          # 后台脚本
│   └── service-worker.js      # Service Worker（MV3）
├── content/
│   ├── content-base.js        # 基础 content script
│   ├── crawlers/              # 各个网站的爬虫模块
│   │   ├── site1.js
│   │   ├── site2.js
│   │   └── site3.js
│   └── features/              # 其他功能模块
│       ├── feature1.js
│       └── feature2.js
├── scripts/                   # 工具函数
│   ├── utils.js
│   ├── storage.js
│   └── api.js
├── popup/                     # 弹窗相关
│   ├── popup.html
│   ├── popup.js
│   └── components/            # UI 组件
│       ├── crawler-panel.js
│       └── feature-panel.js
├── styles/
│   ├── popup.css
│   └── content.css
└── icons/
```

## 实现方式

### 方式1：功能模块化（推荐）

#### manifest.json
```json
{
  "manifest_version": 3,
  "name": "多功能工具插件",
  "version": "1.0.0",
  "permissions": [
    "activeTab",
    "storage",
    "scripting",
    "tabs"
  ],
  "host_permissions": [
    "https://site1.com/*",
    "https://site2.com/*",
    "https://site3.com/*"
  ],
  "background": {
    "service_worker": "background/service-worker.js"
  },
  "action": {
    "default_popup": "popup/popup.html"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content/content-base.js"],
      "css": ["styles/content.css"]
    }
  ]
}
```

#### content/content-base.js
```javascript
// 基础 content script，根据当前网站动态加载对应模块
(async function() {
  const hostname = window.location.hostname;
  
  // 根据域名加载对应的爬虫模块
  const crawlerMap = {
    'site1.com': () => import('./crawlers/site1.js'),
    'site2.com': () => import('./crawlers/site2.js'),
    'site3.com': () => import('./crawlers/site3.js'),
  };
  
  if (crawlerMap[hostname]) {
    const crawler = await crawlerMap[hostname]();
    crawler.init();
  }
  
  // 加载通用功能
  const features = await import('./features/common.js');
  features.init();
})();
```

#### popup/popup.js
```javascript
// 动态加载功能面板
class ExtensionManager {
  constructor() {
    this.features = [];
  }
  
  async init() {
    // 检测当前标签页
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true);
    
    // 根据当前网站显示对应的功能
    this.loadFeaturesForSite(tab.url);
  }
  
  async loadFeaturesForSite(url) {
    const hostname = new URL(url).hostname;
    
    // 显示对应网站的爬虫面板
    if (this.isCrawlableSite(hostname)) {
      await this.loadCrawlerPanel(hostname);
    }
    
    // 加载通用功能面板
    await this.loadCommonFeatures();
  }
  
  async loadCrawlerPanel(site) {
    const panel = await import('./components/crawler-panel.js');
    panel.render(site);
  }
  
  async loadCommonFeatures() {
    const features = await import('./components/feature-panel.js');
    features.render();
  }
}

new ExtensionManager().init();
```

### 方式2：配置驱动

#### config/features.json
```json
{
  "features": [
    {
      "id": "crawler-site1",
      "name": "Site1 爬虫",
      "type": "crawler",
      "sites": ["site1.com"],
      "enabled": true
    },
    {
      "id": "crawler-site2",
      "name": "Site2 爬虫",
      "type": "crawler",
      "sites": ["site2.com"],
      "enabled": true
    },
    {
      "id": "highlight",
      "name": "文本高亮",
      "type": "tool",
      "sites": ["<all_urls>"],
      "enabled": true
    }
  ]
}
```

#### 使用配置
```javascript
// 根据配置动态加载功能
const config = await fetch(chrome.runtime.getURL('config/features.json')).then(r => r.json());

config.features.forEach(feature => {
  if (feature.enabled && matchesCurrentSite(feature.sites)) {
    loadFeature(feature);
  }
});
```

## 优缺点对比

### 单插件方案

**优点：**
- ✅ 统一管理，用户体验好
- ✅ 代码复用，共享工具函数
- ✅ 数据共享，功能间可以协作
- ✅ 维护成本低，一个代码库
- ✅ 版本统一，更新方便

**缺点：**
- ⚠️ 权限合并，可能需要更多权限
- ⚠️ 体积较大，加载时间可能稍长
- ⚠️ 需要良好的代码组织

### 多插件方案

**优点：**
- ✅ 权限独立，更安全
- ✅ 体积小，加载快
- ✅ 可以独立更新

**缺点：**
- ❌ 代码重复，维护成本高
- ❌ 用户体验分散
- ❌ 数据无法共享
- ❌ 安装麻烦，需要安装多个

## 推荐方案

### 场景1：多个网站爬取 + 通用工具
**推荐：单插件 + 模块化**
- 创建一个主插件
- 每个网站一个爬虫模块
- 通用功能作为共享模块
- 使用配置驱动或动态加载

### 场景2：功能完全独立
**推荐：多插件**
- 如果功能之间完全没有关联
- 面向不同的用户群体
- 需要不同的权限级别

### 场景3：核心功能 + 扩展功能
**推荐：混合方案**
- 核心功能：主插件
- 特殊功能：独立插件（如果需要特殊权限）

## 代码组织最佳实践

1. **模块化设计**
   - 每个功能独立模块
   - 使用 ES6 modules
   - 清晰的依赖关系

2. **配置驱动**
   - 功能配置化
   - 易于启用/禁用功能
   - 支持动态加载

3. **统一接口**
   - 所有功能实现统一接口
   - 便于管理和扩展
   - 支持插件化架构

4. **共享资源**
   - 工具函数统一管理
   - 样式和组件复用
   - 数据存储统一

## 示例：功能管理器

```javascript
// managers/feature-manager.js
class FeatureManager {
  constructor() {
    this.features = new Map();
  }
  
  register(name, feature) {
    this.features.set(name, feature);
  }
  
  async loadFeature(name) {
    if (this.features.has(name)) {
      return this.features.get(name);
    }
    
    // 动态加载
    const module = await import(`./features/${name}.js`);
    this.features.set(name, module);
    return module;
  }
  
  async enableFeature(name, context) {
    const feature = await this.loadFeature(name);
    if (feature.enabled && feature.init) {
      await feature.init(context);
    }
  }
}

// 使用
const manager = new FeatureManager();

// 注册功能
manager.register('crawler-site1', {
  enabled: true,
  init: async (context) => {
    // 初始化爬虫
  }
});

// 启用功能
await manager.enableFeature('crawler-site1', { tab });
```

## 总结

对于您的需求，**强烈推荐使用单插件 + 模块化架构**：

1. **更好的用户体验** - 一个插件搞定所有功能
2. **更低的维护成本** - 一个代码库，统一管理
3. **更高的代码复用** - 共享工具和组件
4. **更灵活的扩展** - 易于添加新功能
5. **更好的数据共享** - 功能间可以协作

只需要做好代码组织和模块化设计，单插件方案是最优解。

