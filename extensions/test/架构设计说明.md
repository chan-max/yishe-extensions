# 单插件架构本质说明

## 核心理解

**是的，单插件架构本质上就是一个插件**，只是内部根据不同网站实现了不同的功能。

## 类比理解

### 就像手机上的一个 App

想象一下：
- **多插件方案** = 手机上安装多个独立的 App（微信、支付宝、淘宝...）
  - 每个 App 独立安装
  - 每个 App 有自己的图标
  - 每个 App 功能独立

- **单插件方案** = 手机上安装一个"超级工具箱" App
  - 一个 App 包含多个功能模块
  - 打开 App 后，根据场景显示不同功能
  - 所有功能共享数据、工具、界面

## 具体到 Chrome 插件

### 单插件架构 = 一个插件，多个功能模块

```
一个插件（your-extension）
│
├── manifest.json          # 一个配置文件
├── popup.html             # 一个弹窗界面
│
└── 内部功能模块（根据网站/场景动态加载）
    ├── 网站A爬虫模块
    ├── 网站B爬虫模块
    ├── 网站C爬虫模块
    └── 通用工具模块
```

### 工作流程

1. **用户安装** → 只安装一个插件
2. **用户打开插件** → 显示统一界面
3. **插件检测当前网站** → 自动加载对应功能模块
4. **用户使用** → 看到的是针对当前网站的功能

## 实际例子

### 场景：爬取 3 个网站 + 文本高亮功能

#### 单插件方案（推荐）

```
一个插件：多功能工具
│
├── 用户看到：一个插件图标
├── 点击后：显示功能列表
│   ├── 当前在 site1.com → 显示 "Site1 爬虫" 按钮
│   ├── 当前在 site2.com → 显示 "Site2 爬虫" 按钮
│   ├── 当前在 site3.com → 显示 "Site3 爬虫" 按钮
│   └── 任意网站 → 显示 "文本高亮" 按钮
│
└── 内部实现：
    ├── content/crawlers/site1.js    # Site1 爬虫逻辑
    ├── content/crawlers/site2.js    # Site2 爬虫逻辑
    ├── content/crawlers/site3.js    # Site3 爬虫逻辑
    └── content/features/highlight.js # 高亮功能逻辑
```

#### 多插件方案（不推荐）

```
插件1：Site1 爬虫
├── 独立的 manifest.json
├── 独立的图标
└── 只爬 Site1

插件2：Site2 爬虫
├── 独立的 manifest.json
├── 独立的图标
└── 只爬 Site2

插件3：Site3 爬虫
├── 独立的 manifest.json
├── 独立的图标
└── 只爬 Site3

插件4：文本高亮
├── 独立的 manifest.json
├── 独立的图标
└── 高亮功能
```

## 代码实现示例

### 单插件如何实现"根据不同网站实现不同功能"

#### 1. 检测当前网站

```javascript
// content/content-base.js
const hostname = window.location.hostname;

// 根据域名加载对应模块
if (hostname === 'site1.com') {
  // 加载 Site1 爬虫模块
  import('./crawlers/site1.js').then(module => {
    module.init();
  });
} else if (hostname === 'site2.com') {
  // 加载 Site2 爬虫模块
  import('./crawlers/site2.js').then(module => {
    module.init();
  });
}
```

#### 2. 统一界面，动态显示功能

```javascript
// popup/popup.js
async function showFeatures() {
  const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
  const hostname = new URL(tab.url).hostname;
  
  // 根据当前网站显示对应功能
  if (hostname === 'site1.com') {
    showButton('Site1 爬虫', () => runSite1Crawler());
  } else if (hostname === 'site2.com') {
    showButton('Site2 爬虫', () => runSite2Crawler());
  }
  
  // 通用功能始终显示
  showButton('文本高亮', () => runHighlight());
}
```

#### 3. 功能模块化

```javascript
// content/crawlers/site1.js
export function init() {
  // Site1 特定的爬虫逻辑
  console.log('Site1 爬虫已加载');
}

export function crawl() {
  // 爬取 Site1 的数据
}

// content/crawlers/site2.js
export function init() {
  // Site2 特定的爬虫逻辑
  console.log('Site2 爬虫已加载');
}

export function crawl() {
  // 爬取 Site2 的数据
}
```

## 关键点总结

### ✅ 单插件架构的本质

1. **一个插件** = 一个 manifest.json，一个图标，一次安装
2. **多个功能** = 内部不同的 JavaScript 模块
3. **智能加载** = 根据当前网站/场景自动加载对应模块
4. **统一界面** = 一个弹窗，动态显示相关功能

### 📊 对比表

| 特性 | 单插件架构 | 多插件架构 |
|------|-----------|-----------|
| 安装次数 | 1次 | N次（每个功能一个） |
| 图标数量 | 1个 | N个 |
| 代码复用 | ✅ 可以共享 | ❌ 需要重复 |
| 数据共享 | ✅ 可以共享 | ❌ 无法共享 |
| 维护成本 | ✅ 低（一个代码库） | ❌ 高（多个代码库） |
| 用户体验 | ✅ 好（统一入口） | ❌ 差（分散） |
| 权限管理 | ⚠️ 需要合并权限 | ✅ 独立权限 |

## 实际应用场景

### 场景1：多个网站爬取

**单插件方案：**
```
一个插件：数据采集工具
├── 访问 site1.com → 自动加载 Site1 爬虫模块
├── 访问 site2.com → 自动加载 Site2 爬虫模块
└── 访问 site3.com → 自动加载 Site3 爬虫模块
```

### 场景2：多功能工具集

**单插件方案：**
```
一个插件：开发者工具集
├── 文本高亮功能（所有网站）
├── 代码格式化功能（特定网站）
├── API 测试功能（所有网站）
└── 数据导出功能（所有网站）
```

## 总结

**单插件架构 = 一个插件外壳 + 多个功能模块**

- **外壳**：manifest.json、popup.html、图标等（用户看到的部分）
- **模块**：不同网站/场景的功能实现（内部逻辑）

就像：
- **一个房子（插件）**
- **多个房间（功能模块）**
- **根据需求进入不同房间（根据网站加载不同模块）**

这样既保持了用户体验的统一性，又实现了功能的模块化和可扩展性。

